import {
  Injectable,
  NotFoundException,
  BadRequestException,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../../../prisma/prisma.service';
import { AcceptInvitationDto } from '../dto/accept-invitation.dto';
import { randomUUID } from 'crypto';
import { SupabaseService } from '../../../supabase/supabase.service';
import {
  Invitation,
  AcceptanceState,
  AcceptanceResult,
  StepState,
} from '../types/invitation.types';
import { Prisma } from '@prisma/client';
import { InvitationStatus } from '@prisma/client';

/**
 * Type guard to check if a value is an Error
 */
function isError(error: unknown): error is Error {
  return error instanceof Error;
}

/**
 * Type guard to verify AcceptInvitationDto properties
 */
function hasRequiredDtoProperties(
  dto: AcceptInvitationDto,
): dto is AcceptInvitationDto & {
  firstName: string;
  lastName: string;
  password: string;
} {
  return (
    typeof dto.firstName === 'string' &&
    typeof dto.lastName === 'string' &&
    typeof dto.password === 'string'
  );
}

/**
 * Function to safely generate a UUID
 */
function safeUuidv4(): string {
  try {
    // Use Node.js built-in crypto module which has proper typing
    return randomUUID();
  } catch {
    // Fallback mechanism
    return `fallback-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
  }
}

@Injectable()
export class InvitationsService {
  private readonly logger = new Logger(InvitationsService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly supabaseService: SupabaseService,
  ) {}

  private initializeAcceptanceState(): AcceptanceState {
    return {
      steps: {
        tokenValidation: { success: false },
        userCreation: { success: false },
        roleAssignment: { success: false },
        profileCreation: { success: false },
        invitationUpdate: { success: false },
      },
      currentStep: 'tokenValidation',
      rollbackNeeded: false,
      rollbackSteps: [],
    };
  }

  private async validateInvitationToken(token: string): Promise<{
    state: StepState;
    invitation?: Invitation;
  }> {
    const invitation = await this.prisma.invitation.findFirst({
      where: { token },
    });

    if (!invitation) {
      return {
        state: {
          success: false,
          error: 'Invalid invitation token',
        },
      };
    }

    if (invitation.status !== 'PENDING') {
      return {
        state: {
          success: false,
          error: `Invitation is ${invitation.status.toLowerCase()}`,
        },
        invitation,
      };
    }

    if (invitation.expires_at < new Date()) {
      await this.prisma.invitation.update({
        where: { invitation_id: invitation.invitation_id },
        data: { status: 'EXPIRED' },
      });

      return {
        state: {
          success: false,
          error: 'Invitation has expired',
        },
        invitation: { ...invitation, status: 'EXPIRED' },
      };
    }

    return {
      state: {
        success: true,
        data: invitation,
      },
      invitation,
    };
  }

  private async createUser(
    email: string,
    password: string,
  ): Promise<{
    state: StepState;
    user?: any;
    session?: any;
  }> {
    try {
      const { user, session } = await this.supabaseService.signUp(
        email,
        password,
      );

      if (!user || !session) {
        return {
          state: {
            success: false,
            error: 'Failed to create user account',
          },
        };
      }

      return {
        state: {
          success: true,
          data: { user, session },
        },
        user,
        session,
      };
    } catch (error) {
      return {
        state: {
          success: false,
          error:
            error instanceof Error ? error.message : 'Failed to create user',
        },
      };
    }
  }

  private async assignRole(
    client: any,
    userId: string,
    role: string,
  ): Promise<StepState> {
    try {
      const { error: roleError } = await client.from('user_roles').insert({
        user_id: userId,
        role,
      });

      if (roleError) {
        // Try with admin client if RLS blocks it
        const adminClient = this.supabaseService.getAdminClient();
        const { error: adminRoleError } = await adminClient
          .from('user_roles')
          .insert({
            user_id: userId,
            role,
          });

        if (adminRoleError) {
          return {
            success: false,
            error: adminRoleError.message,
          };
        }
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to assign role',
      };
    }
  }

  private async createRegistrarProfile(
    client: any,
    userId: string,
    email: string,
    firstName: string,
    lastName: string,
  ): Promise<{
    state: StepState;
    registrar?: any;
  }> {
    try {
      const registrar_id = randomUUID();
      const { data: registrar, error: registrarError } = await client
        .from('registrars')
        .insert({
          registrar_id,
          email,
          first_name: firstName,
          last_name: lastName,
          user_id: userId,
        })
        .select()
        .single();

      if (registrarError || !registrar) {
        return {
          state: {
            success: false,
            error:
              registrarError?.message || 'Failed to create registrar profile',
          },
        };
      }

      return {
        state: {
          success: true,
          data: registrar,
        },
        registrar,
      };
    } catch (error) {
      return {
        state: {
          success: false,
          error:
            error instanceof Error ? error.message : 'Failed to create profile',
        },
      };
    }
  }

  private async updateInvitationStatus(
    client: any,
    invitationId: string,
    email: string,
  ): Promise<StepState> {
    try {
      const { error } = await client
        .from('invitations')
        .update({ status: 'ACCEPTED' })
        .eq('invitation_id', invitationId)
        .eq('email', email);

      if (error) {
        return {
          success: false,
          error: error.message,
        };
      }

      return { success: true };
    } catch (error) {
      return {
        success: false,
        error:
          error instanceof Error
            ? error.message
            : 'Failed to update invitation',
      };
    }
  }

  /**
   * Find all invitations with optional status filter
   */
  async findAll(status?: string) {
    try {
      // Use a safe record for the where clause with proper typing
      const where: Record<string, any> = {};

      if (status) {
        // Convert the string status to the proper enum
        where.status = status.toUpperCase() as InvitationStatus;
      }

      return await this.prisma.invitation.findMany({
        where,
        orderBy: {
          created_at: 'desc',
        },
      });
    } catch (error) {
      this.logger.error(
        `Failed to find invitations: ${error.message}`,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Failed to find invitations: ${error.message}`,
      );
    }
  }

  /**
   * Find a single invitation by ID
   */
  async findOne(invitation_id: string) {
    try {
      const invitation = await this.prisma.invitation.findUnique({
        where: { invitation_id },
      });

      if (!invitation) {
        throw new NotFoundException(
          `Invitation with ID ${invitation_id} not found`,
        );
      }

      return invitation;
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }

      this.logger.error(
        `Failed to find invitation: ${error.message}`,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Failed to find invitation: ${error.message}`,
      );
    }
  }

  /**
   * Validate invitation token
   */
  async validateToken(token: string) {
    try {
      const invitation = await this.prisma.invitation.findFirst({
        where: { token },
      });

      if (!invitation) {
        return {
          valid: false,
          message: 'Invalid invitation token',
        };
      }

      if (invitation.status !== InvitationStatus.PENDING) {
        return {
          valid: false,
          message: `Invitation is ${invitation.status.toLowerCase()}`,
          invitation,
        };
      }

      if (invitation.expires_at < new Date()) {
        // Automatically update to expired
        await this.prisma.invitation.update({
          where: { invitation_id: invitation.invitation_id },
          data: {
            status: InvitationStatus.EXPIRED,
          },
        });

        return {
          valid: false,
          message: 'Invitation has expired',
          invitation: { ...invitation, status: InvitationStatus.EXPIRED },
        };
      }

      return {
        valid: true,
        message: 'Invitation token is valid',
        invitation,
      };
    } catch (error) {
      this.logger.error(
        `Failed to validate token: ${error.message}`,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Failed to validate token: ${error.message}`,
      );
    }
  }

  /**
   * Accept an invitation with cleaner error handling
   */
  async acceptInvitation(token: string, dto: AcceptInvitationDto) {
    try {
      // Step 1: Validate the invitation token
      const validation = await this.validateToken(token);

      if (!validation.valid || !validation.invitation) {
        throw new BadRequestException(validation.message);
      }

      const invitation = validation.invitation;

      // Step 2: Create the user account
      const { user, session } = await this.supabaseService.signUp(
        invitation.email,
        dto.password,
      );

      if (!user || !session) {
        throw new InternalServerErrorException('Failed to create user account');
      }

      // Create a client with the new user's token
      const client = this.supabaseService.getClientWithAuth(
        session.access_token,
      );

      try {
        // Step 3: Try to insert the user role
        const { error: roleError } = await client.from('user_roles').insert({
          user_id: user.id,
          role: invitation.user_type,
        });

        if (roleError) {
          this.logger.warn(`Role creation failed: ${roleError.message}`);

          // Clean up the user if role creation fails
          await this.supabaseService.deleteUser(user.id);
          throw new InternalServerErrorException(
            `Role creation failed: ${roleError.message}`,
          );
        }
      } catch (error) {
        // If role assignment fails, clean up the user
        await this.supabaseService.deleteUser(user.id);
        throw new InternalServerErrorException(
          `Role assignment failed: ${error.message}`,
        );
      }

      // Step 4: Create the appropriate profile based on user type
      try {
        if (invitation.user_type === 'REGISTRAR') {
          // Create registrar profile
          const { data: registrar, error: registrarError } = await client
            .from('registrars')
            .insert({
              registrar_id: randomUUID(),
              email: user.email,
              first_name: dto.firstName,
              last_name: dto.lastName,
              user_id: user.id,
            })
            .select()
            .single();

          if (registrarError || !registrar) {
            throw new Error(
              registrarError?.message || 'Failed to create registrar profile',
            );
          }

          // Step 5: Update the invitation status
          await this.updateInvitationStatus(
            invitation.invitation_id,
            InvitationStatus.ACCEPTED,
          );

          // Return the complete response
          return {
            user: {
              id: user.id,
              email: user.email,
              first_name: dto.firstName,
              last_name: dto.lastName,
              role: invitation.user_type,
            },
            session: {
              access_token: session.access_token,
              refresh_token: session.refresh_token,
            },
            registrar,
          };
        } else if (invitation.user_type === 'STUDENT') {
          // Handle student creation (implementation left out for brevity)
          throw new BadRequestException(
            'Student registration not implemented yet',
          );
        } else {
          throw new BadRequestException(
            `Unsupported user type: ${invitation.user_type}`,
          );
        }
      } catch (error) {
        // If profile creation fails, clean up the user
        await this.supabaseService.deleteUser(user.id);
        throw new InternalServerErrorException(
          `Profile creation failed: ${error.message}`,
        );
      }
    } catch (error) {
      this.logger.error(
        `Invitation acceptance failed: ${error.message}`,
        error.stack,
      );

      if (
        error instanceof BadRequestException ||
        error instanceof NotFoundException ||
        error instanceof InternalServerErrorException
      ) {
        throw error;
      }

      throw new InternalServerErrorException(
        `Failed to accept invitation: ${error.message}`,
      );
    }
  }

  /**
   * Resend an invitation with a new token and expiration date
   */
  async resendInvitation(invitation_id: string) {
    try {
      const invitation = await this.findOne(invitation_id);

      if (invitation.status !== InvitationStatus.PENDING) {
        throw new BadRequestException(
          `Invitation is ${invitation.status.toLowerCase()}, cannot be resent`,
        );
      }

      // Generate new token and update expiry
      const token = randomUUID();
      const expires_at = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

      const updatedInvitation = await this.prisma.invitation.update({
        where: { invitation_id },
        data: { token, expires_at },
      });

      return {
        success: true,
        message: `Invitation resent to ${invitation.email}`,
        invitation: updatedInvitation,
      };
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }

      this.logger.error(
        `Failed to resend invitation: ${error.message}`,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Failed to resend invitation: ${error.message}`,
      );
    }
  }

  /**
   * Cancel an invitation
   */
  async cancelInvitation(invitation_id: string) {
    try {
      const invitation = await this.findOne(invitation_id);

      if (invitation.status !== InvitationStatus.PENDING) {
        throw new BadRequestException(
          `Invitation is ${invitation.status.toLowerCase()}, cannot be cancelled`,
        );
      }

      const updatedInvitation = await this.updateInvitationStatus(
        invitation_id,
        InvitationStatus.CANCELLED,
      );

      return {
        success: true,
        message: `Invitation to ${invitation.email} has been cancelled`,
        invitation: updatedInvitation,
      };
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }

      this.logger.error(
        `Failed to cancel invitation: ${error.message}`,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Failed to cancel invitation: ${error.message}`,
      );
    }
  }

  /**
   * Remove an invitation
   */
  async remove(invitation_id: string) {
    try {
      await this.findOne(invitation_id);

      await this.prisma.invitation.delete({
        where: { invitation_id },
      });

      return {
        success: true,
        message: `Invitation with ID ${invitation_id} has been removed`,
      };
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }

      this.logger.error(
        `Failed to remove invitation: ${error.message}`,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Failed to remove invitation: ${error.message}`,
      );
    }
  }

  /**
   * Helper method to update invitation status directly in database
   */
  private async updateInvitationStatus(
    invitation_id: string,
    status: InvitationStatus,
  ) {
    try {
      return await this.prisma.invitation.update({
        where: { invitation_id },
        data: { status },
      });
    } catch (error) {
      this.logger.error(
        `Failed to update invitation status: ${error.message}`,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Failed to update invitation status: ${error.message}`,
      );
    }
  }
}
